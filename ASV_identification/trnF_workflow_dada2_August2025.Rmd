---
title: "trnF data analysis"
author: "Pedro Rodrigues"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 3
    fig_caption: yes

fontsize: 14pt
---

# Introduction

We extracted DNA from three batches of burrower bugs (Cydnidae) collected in peanut fields grown in southern GA, USA. A portion of the chloroplast _trnF_ gene was sequenced from these samples, to characterize the diet of these insects. Here, these three batches of sequencing data, PBB1, PBB2, and PBB3, are quality-trimmed and noise-filtered before being combined and classified into plant taxa. Two species of burrower bugs are represented in this data, and we test whether their diet is different, identify instances of peanut consumption, and test whether their diet changes across time and sampling location.


# Setup

Prepare environment
Load packages

```{r init, warning=FALSE, message=FALSE}

setwd("/Users/ento-user/Documents/Github_Burrower_Bug/Burrower-Bugs-diet-and-pop-gen/ASV_identification")
set.seed("1805")

library(dada2);packageVersion("dada2") #‘1.30.0’
library(Biostrings); packageVersion("Biostrings") #‘2.70.3’
library(ShortRead); packageVersion("ShortRead") #‘1.60.0’
library(ggplot2); packageVersion("ggplot2") #‘3.5.0’
library(reshape2); packageVersion("reshape2") #‘1.4.4’
library(gridExtra); packageVersion("gridExtra") #‘2.3’
library(phyloseq); packageVersion("phyloseq") #‘1.46.0’
library(dplyr); packageVersion("dplyr") #‘1.1.4’
library(vegan); packageVersion("vegan") #'2.6.4'
```

```{r more preparation, warning=FALSE, message=FALSE}
pathPBB1 <- "../diet_data/PBB1"
pathPBB2 <- "../diet_data/PBB2"
pathPBB3 <- "../diet_data/PBB3"
path.out <- "Figures/"
path.rds <- "RDS/"
fnsPBB1 <- list.files(pathPBB1, pattern=".fastq", full.names=TRUE)
fnsPBB2 <- list.files(pathPBB2, pattern=".fastq", full.names=TRUE)
fnsPBB3 <- list.files(pathPBB3, pattern=".fastq", full.names=TRUE)
B49873_e <- "GGTTCAAGTCCCTCTATCCC"
A50272_f <- "ATTTGAACTGGTGACACGAG"
rc <- dada2:::rc
theme_set(theme_bw())
```


# Primer removal and filtering
## Remove Primers and Filter (PBB3)

Remove primers and orient reads:
```{r primers3}
nops3 <- file.path(pathPBB3, "noprimers", basename(fnsPBB3))
prim3 <- removePrimers(fnsPBB3, nops3, primer.fwd=B49873_e, primer.rev=dada2:::rc(A50272_f), orient=TRUE)
```

Inspect length distribution.
```{r length-distro3}
lens.fn3 <- lapply(nops3, function(fn) nchar(getSequences(fn)))
lens3 <- do.call(c, lens.fn3)
hist(lens3, 100)
min(lens3)
max(lens3)
```

There is a wide range of lengths in these samples - this is expected. Let's check what is the minimum size expected based on the trnF database that I created using the NCBI RefSeq chloroplasts genomes

In UNIX, I get the following result (see below)
```
(base) pd88715@ss-sub3 ref_seq_plastids$ cat trnF_db11Feb22.fa | awk '$0 ~ ">" {if (NR > 1) {print c;} c=0;printf substr($0,2,100) "\t"; } $0 !~ ">" {c+=length($0);} END { print c; }' | cut -f 2 | sort -n | head
101
102
102
102
102
102
102
103
103
103
```
>NOTE: one of the settings for building this reference trnF intergenic gene database is removing sequences smaller than 100bp

### Filter and Trim PBB3
>Note on maxEE - for fungal identification using ITS1 it was found that increasing maxEE = 8 increased the number of reads per taxa expected to be present in the sample (Rolling et al. 2021); previously I used maxEE=2, and had to rarefy data in downstream analysis to 100 sequences/sample, which was very low; I am using maxEE=8 to increase the number of reads per plant species
source https://insight.jci.org/articles/view/151663

```{r filter3}
filts3 <- file.path(pathPBB3, "noprimers", "filtered", basename(fnsPBB3))
track3 <- filterAndTrim(nops3, filts3, minQ=3, minLen=100, maxN=0, rm.phix=FALSE, maxEE=8)
track3
```

## Denoise data with DADA2

Dereplicate
```{r derep3, message=FALSE}
drp3 <- derepFastq(filts3, verbose=TRUE)
```


Learn errors
```{r learn-err3}
err3 <- learnErrors(drp3, errorEstimationFunction=PacBioErrfun, BAND_SIZE=32, multithread=TRUE)
saveRDS(err3, file.path(path.rds, "PBB3_err2.rds")) #name changes here, keeping previous files generated by version 1 of this workflow
```

Inspect errors
```{r see-err3}
plotErrors(err3)
```

Looks good: base error decreases with higher base quality scores.

Denoise
```{r dada2-sample3}
dd3 <- dada(drp3, err=err3, BAND_SIZE=32, multithread=TRUE)
saveRDS(dd3, file.path(path.rds, "PBB3_dd3_2.rds"))
```
Not a lot of losses. PacBio stringent pre-filtering probably already excluded most of the low quality sequences.
There is generally more reads than unique reads, which is a good sign.

Read tracking for PBB3
```{r}
cbind(ccs=prim3[,1], primers=prim3[,2], filtered=track3[,2], denoised=sapply(dd3, function(x) sum(x$denoised)))
```

Sequence table for PBB3:
```{r seqtab3}
st3 <- makeSequenceTable(dd3); dim(st3)
```

Here is a good point to save the sequence table and use this table when merging with other datasets (PBB1 and PBB2).
```{r save seq table3}
saveRDS(st3, "RDS/PBB3_2.rds")
```


------------------------------------------


## Process the other two datasets (PBB1 and PBB2), and combine all results into one single dataset

*Starting with PBB1*

Remove primers and orient reads:
```{r primers1, message=FALSE, warning=FALSE}
nops1 <- file.path(pathPBB1, "noprimers", basename(fnsPBB1))
prim1 <- removePrimers(fnsPBB1, nops1, primer.fwd=B49873_e, primer.rev=dada2:::rc(A50272_f), orient=TRUE)
```

Inspect length distribution.
```{r length-distro1}
lens.fn <- lapply(nops1, function(fn) nchar(getSequences(fn)))
lens <- do.call(c, lens.fn)
hist(lens, 100)
min(lens)
max(lens)
```

Filter and Trim
maxEE=8
```{r filter1}
filts1 <- file.path(pathPBB1, "noprimers", "filtered", basename(fnsPBB1))
track1 <- filterAndTrim(nops1, filts1, minQ=3, minLen=100, maxN=0, rm.phix=FALSE, maxEE=8)
track1
```

Dereplicate:
```{r derep1, warning=FALSE, message=FALSE}
drp1 <- derepFastq(filts1, verbose=TRUE)
```

Learn errors:
```{r learn-err1}
err1 <- learnErrors(drp1, errorEstimationFunction=PacBioErrfun, BAND_SIZE=32, multithread=TRUE)
saveRDS(err1, file.path(path.rds, "err_PBB1_2.rds"))
```

Inspect errors:
```{r see-err1}
plotErrors(err1)
```

Looks good.

Denoise:
```{r dada2-sample1}
dd1 <- dada(drp1, err=err1, BAND_SIZE=32, multithread=TRUE)
saveRDS(dd1, file.path(path.rds, "PBB1_dd1_2.rds"))
```

Read tracking for PBB1:
```{r}
cbind(ccs=prim1[,1], primers=prim1[,2], filtered=track1[,2], denoised=sapply(dd1, function(x) sum(x$denoised)))
```

Sequence table:
```{r seqtab1}
st1 <- makeSequenceTable(dd1); dim(st1)
```
Save progress here before moving to PBB2.
```{r save seq table1}
saveRDS(st1, "RDS/PBB1_2.rds")
```

*Repeat for PBB2*

Remove primers and orient reads:
```{r primers2, message=FALSE, warning=FALSE}
nops2 <- file.path(pathPBB2, "noprimers", basename(fnsPBB2))
prim2 <- removePrimers(fnsPBB2, nops2, primer.fwd=B49873_e, primer.rev=dada2:::rc(A50272_f), orient=TRUE)
```

Inspect length distribution.
```{r length-distro}
lens.fn2 <- lapply(nops2, function(fn) nchar(getSequences(fn)))
lens2 <- do.call(c, lens.fn2)
hist(lens2, 100)
min(lens2)
max(lens2)
```

Filter and Trim
maxEE=8
```{r filter2}
filts2 <- file.path(pathPBB2, "noprimers", "filtered", basename(fnsPBB2))
track2 <- filterAndTrim(nops2, filts2, minQ=3, minLen=100, maxN=0, rm.phix=FALSE, maxEE=8)
track2
```

Dereplicate:
```{r derep2, message=FALSE}
drp2 <- derepFastq(filts2, verbose=TRUE)
```

Learn errors:
```{r learn-err2}
err2 <- learnErrors(drp2, errorEstimationFunction=PacBioErrfun, BAND_SIZE=32, multithread=TRUE)
saveRDS(err2, file.path(path.rds, "err_PBB2_2.rds"))
```

Inspect errors:
```{r see-err2}
plotErrors(err2)
```

Looks good.

Denoise:
```{r dada2-sample-2}
dd2 <- dada(drp2, err=err2, BAND_SIZE=32, multithread=TRUE)
saveRDS(dd2, file.path(path.rds, "PBB2_dd2_2.rds"))
```

Read tracking for PBB2:
```{r}
cbind(ccs=prim2[,1], primers=prim2[,2], filtered=track2[,2], denoised=sapply(dd2, function(x) sum(x$denoised)))
```

Sequence table:
```{r seqtab2}
st2 <- makeSequenceTable(dd2); dim(st2)
```

Save progress for PBB2 and next merge datafiles for downstream analyses.
```{r save seq table2}
saveRDS(st2, "RDS/PBB2_2.rds")
```


*Combine all quality-trimmed files*

```{r combine-files}
st1 <- readRDS("RDS/PBB1_2.rds")
st2 <- readRDS("RDS/PBB2_2.rds")
st3 <- readRDS("RDS/PBB3_2.rds")
st.all <- mergeSequenceTables(st1, st2, st3)
```

## Remove chimeras, assign taxonomy and save progress
```{r remove-chimeras}
st.all_chimera_free <- removeBimeraDenovo(st.all, method="consensus", multithread=TRUE, verbose = TRUE)
```

```{r assign taxonomy}
# Assign taxonomy
tax <- assignTaxonomy(st.all, "./trnF_db11Feb22.fa", minBoot = 80, tryRC = TRUE, multithread=TRUE) # Slowest part
head(unname(tax))
```

```{r save-progrss-taxonomy}
# Write to disk
saveRDS(st.all, "RDS/PBB_all_runs_2.rds")
saveRDS(tax, "RDS/PBB_all_runs_tax_2.rds")
```

> NOTE: taxonomy will be improved later, using BLAST (nt database), but only after the ASV table is further cleaned up in Phyloseq

# Move analysis over to Phyloseq
## Load all runs RDS files (ASV table file and taxonomy file)
Also load metadata file, where sample names are row names

```{r phyloseq-load-data}
library(dplyr)
st.all_chimera_free <- readRDS("RDS/PBB_all_runs_2.rds")
tax <- readRDS("RDS/PBB_all_runs_tax_2.rds")
metadata <- read.table("./metadata_assembly/Burrower_bugs_metadata_DEC32024.csv", row.names = 3, sep = ",", header = TRUE) # Note, exclude first column (row number) before loading this spreadsheet
metadata$SequenceBatch <- as.factor(metadata$SequenceBatch)
metadata$collection_date <- as.Date(metadata$collection_date, format = "%m/%d/%y")
metadata$Month <- factor(metadata$Month, levels = month.name)
metadata_up <- metadata
```

Make Phyloseq object
```{r phyloseq-make-object-1}
p_data <- phyloseq(otu_table(st.all_chimera_free, taxa_are_rows = FALSE),
                   sample_data(metadata),
                   tax_table(tax))
```

Store DNA sequences in different slot and simplify ASV names
```{r phyloseq-format-data}
dna <- Biostrings::DNAStringSet(taxa_names(p_data))
names(dna) <- taxa_names(p_data)
p_data <- merge_phyloseq(p_data, dna)
taxa_names(p_data) <- paste0("ASV", seq(ntaxa(p_data)))
p_data
```

## Decontam
```{r decontam-eval-data}
library(decontam)
df <- as.data.frame(sample_data(p_data))
df$LibrarySize <- sample_sums(p_data)
df <- df[order(df$LibrarySize),]
df$Index <- seq(nrow(df))
ggplot(data=df, aes(x=Index, y=LibrarySize, color=sample_type)) + geom_point()
sample_data(p_data)$is.neg <- sample_data(p_data)$sample_type == "control"

# adopting prevalence method to identify contaminants based on controls
# sensitivity set to low (threhold = 0.1)
contamdf.prev.01 <- isContaminant(p_data, method="prevalence", neg="is.neg")
table(contamdf.prev.01$contaminant)
contaminant.list <- which(contamdf.prev.01$contaminant)
tax_table(p_data)[contaminant.list,]

# sensitivity set to high (threshold = 0.5)
contamdf.prev.05 <- isContaminant(p_data, method="prevalence", neg="is.neg", threshold = 0.5)
table(contamdf.prev.05$contaminant)
contaminant.list <- which(contamdf.prev.05$contaminant)
tax_table(p_data)[contaminant.list,]
```

We identified via PCR that some reagents (e.g. some primer-barcode combinations) were likely contaminated with plant DNA.
Suspect contaminants such as Citrus only show up as contaminant when sensitivity is increased to 0.5.

Let's inspect how contaminants prevalence is divided between control and samples

```{r decontam-eval-distribution}
# Make phyloseq object of presence-absence in negative controls and true samples
ps.pa <- transform_sample_counts(p_data, function(abund) 1*(abund>0))
ps.pa.neg <- prune_samples(sample_data(ps.pa)$sample_type == "control", ps.pa)
ps.pa.pos <- prune_samples(sample_data(ps.pa)$sample_type == "sample", ps.pa)
# Make data.frame of prevalence in positive and negative samples
# for threshold=0.1
df.pa1 <- data.frame(pa.pos=taxa_sums(ps.pa.pos), pa.neg=taxa_sums(ps.pa.neg),
                      contaminant=contamdf.prev.01$contaminant)
ggplot(data=df.pa1, aes(x=pa.neg, y=pa.pos, color=contaminant)) + geom_point() +
  xlab("Prevalence (Negative Controls)") + ylab("Prevalence (True Samples)") + ggtitle("Decontamination threshold=0.1")
# for threshold=0.5
df.pa5 <- data.frame(pa.pos=taxa_sums(ps.pa.pos), pa.neg=taxa_sums(ps.pa.neg),
                      contaminant=contamdf.prev.05$contaminant)
ggplot(data=df.pa5, aes(x=pa.neg, y=pa.pos, color=contaminant)) + geom_point() +
  xlab("Prevalence (Negative Controls)") + ylab("Prevalence (True Samples)") + ggtitle("Decontamination threshold=0.5")

p_data.ord <- ordinate(p_data, "PCoA", "bray")
plot_ordination(p_data, p_data.ord, type="sample", color="sample_type", shape="SequenceBatch")+ geom_point(size=3)
```

Because it is hard to distinguish whether contaminated primers were contaminated by the samples themselves, or whether it was contaminated water that was used for dilution, or both (likely), there is a risk that a more rigorous cutoff for contaminants will likely remove false-positives as well.
On the other hand, a soft filter may leave out some likely contaminants such as Citrus.
```{r decontam-clean-data}
p_data.noncontam <- prune_taxa(!contamdf.prev.05$contaminant, p_data)
p_data
p_data.noncontam
# Remove control samples from analysis
p_data.clean <-subset_samples(p_data.noncontam, sample_type!="control")
# Remove samples with zero ASV (zero column sums)
p_data.clean <- subset_samples(p_data.clean, sample_sums(p_data.clean) > 0)
```


> At this point, the taxonomy table is likely to contain fewer (or no) spurious sequences
> Therefore, this is a good point to export the taxonomy table as a fasta file and run Blast to improve genus assignment (i.e. replace NAs)

#### Save taxonomy table

```{r save-taxonomy-table}
p_data.clean %>%
  tax_table() %>%
  write.csv("./PBB123_asv_11182024.csv")
```

#### Save sequences as a fasta file for blast, use the following command
```{r save-sequences-fasta}
p_data.clean %>%
      refseq() %>%
      Biostrings::writeXStringSet("./PBB123_asv_11182024.fasta", append=FALSE,
                                  compress=FALSE, compression_level=NA, format="fasta")
```

#### Save decontaminated phyloseq object and its components

```{r save-progress}
saveRDS(otu_table(p_data.clean), "RDS/p_data.cleanOTU.rds")
saveRDS(sample_data(p_data.clean), "RDS/p_data.cleanSampleData.rds")
saveRDS(tax_table(p_data.clean), "RDS/p_data.cleanOTUTaxaTable.rds")
saveRDS(refseq(p_data.clean), "RDS/p_data.cleanOTURefSeq.rds")
```


> This concludes part 1 of cleaning, denoising and classifying sequences in these samples. The next portion, part 2, is focused on determining taxonomy for some of the undetermined taxa, as well as excluding taxa that aren't relevant for this study, such as bryphoyte and algae.

# Part 2, adding results from blast search

Prepare environment:

Load Data

```{r phyloseq-load-improved-data}
p_data.cleanOTU <- readRDS("RDS/p_data.cleanOTU.rds")
p_data.cleanSampleData <- readRDS("RDS/p_data.cleanSampleData.rds")
p_data.cleanOTUTaxaTable <- readRDS("RDS/p_data.cleanOTUTaxaTable.rds")
p_data.cleanOTURefSeq <- readRDS("RDS/p_data.cleanOTURefSeq.rds")
```

Make Phyloseq object
```{r phyloseq-make-object}
p_data.clean <- phyloseq(otu_table(p_data.cleanOTU, taxa_are_rows = FALSE),
                   sample_data(p_data.cleanSampleData),
                   tax_table(p_data.cleanOTUTaxaTable),
                   refseq(p_data.cleanOTURefSeq))
```


>Blast was executed using script in blast_ASV_pbb123.sh
PBB123_asv_11182024a.csv (taxonomy table) was edited and every NA was changed if taxonomic information was available (a blast hit result)
NOTE: taxonomical assignments ranged from about 95% to 100% and some NAs remained with no classification via Blast

#### Add new taxonomical information to Phyloseq object

```{r add-new-taxon-table}
new_tax_table <- read.csv("PBB123_asv_11182024a.csv", row.names = 1)
new_tax <- tax_table(as.matrix(new_tax_table))
tax_table(p_data.clean) <- new_tax
```

## Further cleaning taxonomical data

List all instances where Genus == NA
```{r list-genus-NA}
#tax_table(p_data.clean) %>% as("matrix") %>% as_tibble
p_data.clean %>%
  subset_taxa(is.na(Genus)) %>%
 tax_table()
```

All but a few instance of Genus=NA are ASV where Kingdom is also NA. As a conservative approach, I will exclude everything that is not identified as Viridiplantae at the Kingdom level

Remove singletons if needed and taxa where Order = NA
Remove instances where algae was identified
Remove samples where count is zero

```{r prepare-for-downstream-diversity-analysis}
tail(taxa_sums(p_data.clean) < 2)
p_data.clean <- prune_taxa(taxa_sums(p_data.clean) > 1, p_data.clean) %>% subset_taxa(., Kingdom == "Viridiplantae")
p_data.clean <- subset_samples(p_data.clean, sample_sums(p_data.clean) > 0)
```

Sanity check - is there any NA left for Genus?
```{r list-genus-NA-2}
#tax_table(p_data.clean) %>% as("matrix") %>% as_tibble
p_data.clean %>%
  subset_taxa(is.na(Genus)) %>%
 tax_table()
```

These ASVs have an inconclusive identification for Genus. In addition, there is taxa here that are still likely not part of these bugs' diet (e.g. Bryophytes).

Checking for mosses and other unexpected taxa
```{r are-there-mosses}
# are there unexpected taxa?
unique(tax_table(p_data.clean)[,3])
```

Mosses are the only unexpected taxa.
Remove mosses with the following command
```{r remove-mosses}
# How many ASVs are mosses?
p_data.clean %>% subset_taxa(., Class == "Bryopsida") %>% tax_table() # two ASVs
p_data.clean
p_data.clean <- subset_taxa(p_data.clean, Class != "Bryopsida")
p_data.clean # now there are two fewer ASVs
```

```{r save-progress-2}
saveRDS(otu_table(p_data.clean), "RDS/p_data.cleanOTU_cleaningcompleted.rds")
saveRDS(sample_data(p_data.clean), "RDS/p_data.cleanSampleData_cleaningcompleted.rds")
saveRDS(tax_table(p_data.clean), "RDS/p_data.cleanOTUTaxaTable_cleaningcompleted.rds")
saveRDS(refseq(p_data.clean), "RDS/p_data.cleanOTURefSeq_cleaningcompleted.rds")
```

>This concludes part 2 of (the bulk of) cleaning up and classifying data. Next, in part 3, I do more hypothesis-guided analyses, including figures and statistical tests.

#Part 3, figures, ordination and statistical tests

Load Data

```{r phyloseq-load-improved-data}
p_data.cleanOTU <- readRDS("RDS/p_data.cleanOTU_cleaningcompleted.rds")
#metadata <- readRDS("RDS/p_data.cleanSampleData_cleaningcompleted.rds")
metadata <- metadata_up
p_data.cleanOTUTaxaTable <- readRDS("RDS/p_data.cleanOTUTaxaTable_cleaningcompleted.rds")
p_data.cleanOTURefSeq <- readRDS("RDS/p_data.cleanOTURefSeq_cleaningcompleted.rds")
```

Make Phyloseq object
```{r phyloseq-make-object}
p_data.clean <- phyloseq(otu_table(p_data.cleanOTU, taxa_are_rows = FALSE),
                   sample_data(metadata),
                   tax_table(p_data.cleanOTUTaxaTable),
                   refseq(p_data.cleanOTURefSeq))
```

## Rarefaction
Basic stats and rarefying data

First let's separate the data into two different groups: data for the peanut burrower bug _Pangaeus_ _bilineatus_ and data belonging to _Dallasiellus_ _lugubris_

```{r separate-species-2}
p_data.clean_batch1out <- subset_samples(p_data.clean, SequenceBatch != "1") # exclude "batch 1" which is data without a validated species ID
Pbilineatus <- subset_samples(p_data.clean_batch1out, Sp.ID=="Pbilineatus") %>% prune_taxa(taxa_sums(.) > 1, .)
Dlugubris <- subset_samples(p_data.clean_batch1out, Sp.ID=="Dlugubris") %>% prune_taxa(taxa_sums(.) > 1, .)
Pbilineatus
Dlugubris
```

From 34 samples identified as P. bilineatus, only 22 samples passed our quality control. There are another 32 samples that were initially identified as P. bilineatus, but we were not able to validate this identification by molecular methods (i.e. alignment against our reference genome) because the genomes of these samples were not sequenced (RAD-seq). However, we may include these samples back later in this analysis, in case we find significant differences between the diet of these two species that may allow us to classify these samples according to their diet.

From 67 samples identified as D. lugubris, 61 samples passed our quality control.

Now, what is the sample size variation per species?
```{r sample-size-variation-2}
# P. bilineatus
len_samplepb <- as.data.frame(sample_sums(Pbilineatus))
median(len_samplepb$`sample_sums(Pbilineatus)`)
mean(len_samplepb$`sample_sums(Pbilineatus)`)
min(len_samplepb$`sample_sums(Pbilineatus)`)
max(len_samplepb$`sample_sums(Pbilineatus)`)
# D. lugubris
len_sampledl <- as.data.frame(sample_sums(Dlugubris))
median(len_sampledl$`sample_sums(Dlugubris)`)
mean(len_sampledl$`sample_sums(Dlugubris)`)
min(len_sampledl$`sample_sums(Dlugubris)`)
max(len_sampledl$`sample_sums(Dlugubris)`)
```

To visualize distribution in each case, I will exclude the largest samples and focus on the other samples

```{r plot-sample-size-pbilineatus}
#Exclude largest samples to build histogram
len_samplepb <-subset(len_samplepb, len_samplepb$`sample_sums(Pbilineatus)` < 1200)
median(len_samplepb$`sample_sums(Pbilineatus)`)
hist(len_samplepb$`sample_sums(Pbilineatus)`, 10)
```

```{r plot-sample-size-dlugubris}
#Exclude largest samples to build histogram
len_sampledl <-subset(len_sampledl, len_sampledl$`sample_sums(Dlugubris)` < 1200)
median(len_sampledl$`sample_sums(Dlugubris)`)
hist(len_sampledl$`sample_sums(Dlugubris)`, 10)
```

When extremely large samples are excluded, average number of reads per sample is under 100 reads per sample for either species.
Rarefying samples at 100 reads per sample would keep close to half of the samples for each species in the dataset. So, a higher replicate size at the individual level (insect) at the cost of shallower sampling of the diet per individual. However, using a higher sample size cutoff for diet may be better to characterize food items commonly consumed by these insects, at the cost of decreasing the replication at the individual (insect) sampling size. Since the cutoff is the same, then I can rarefy the p_data.clean, to run statistics to compare both species directly. If necessary, I can separate samples as well after they are rarefied.

How many samples do I loose by keeping only samples with a relatively deeper sequencing of diet?
Rather than arbitrarily picking a single sequencing depth, I will compare the relative thresholds and number of samples kept in the dataset using quantiles (25,50,75) of the sample size variation in this dataset as a whole, using 1000 iterations via the rarefaction function from the metagMisc package.

```{r rarefy-function-from-metagMisc}
#devtools::install_github("vmikk/metagMisc")
library(metagMisc)
```

```{r rarefy-data}
p_data.clean_rarefy <- subset_samples(p_data.clean, Site != "Colony") # exclude captive burrower bugs only fed peanuts
otu_table(p_data.clean_rarefy) <- otu_table(t(otu_table(p_data.clean_rarefy)), taxa_are_rows=TRUE)
sample_size_quantile <- as.data.frame(quantile(sample_sums(p_data.clean_rarefy), probs = c(0, 0.10, 0.15, 0.225, 0.25, 0.5, 0.75, 1)))
threshold25 <- sample_size_quantile["25%", ]
threshold50 <- sample_size_quantile["50%", ]
threshold75 <- sample_size_quantile["75%", ]
PBB_rr25 <- phyloseq_mult_raref_avg(p_data.clean_rarefy, SampSize = threshold25, iter=1000, parallel = TRUE,verbose = TRUE)
PBB_rr50 <- phyloseq_mult_raref_avg(p_data.clean_rarefy, SampSize = threshold50, iter=1000, parallel = TRUE,verbose = TRUE)
PBB_rr75 <- phyloseq_mult_raref_avg(p_data.clean_rarefy, SampSize = threshold75, iter=1000, parallel = TRUE,verbose = TRUE)
PBB_rr25 <- transform_sample_counts(PBB_rr25, function(x){ x * threshold25})
PBB_rr50 <- transform_sample_counts(PBB_rr50, function(x){ x * threshold50})
PBB_rr75 <- transform_sample_counts(PBB_rr75, function(x){ x * threshold75})
p_data.clean_rarefy
PBB_rr25
PBB_rr50
PBB_rr75
```

```{r saveRarefied}
saveRDS(PBB_rr25, "RDS/PBB_rr25.rds")
saveRDS(PBB_rr50, "RDS/PBB_rr50.rds")
saveRDS(PBB_rr75, "RDS/PBB_rr75.rds")
```

## Are their diets different?

First, I will check general patterns: what are the most common or prevalent diet items found in each species?

```{r common-diet-items}
Pbilineatus_g <- p_data.clean %>% subset_samples(Sp.ID == "Pbilineatus") %>% subset_samples(!Site == "Colony") %>% tax_glom(taxrank = "Genus")
Dlugubris_g <- tax_glom(Dlugubris, taxrank = "Genus")
Pbilineatus_g %>% otu_table() %>% as.data.frame() %>% t() %>% rowSums() %>% sort(decreasing = TRUE) %>% head(10)
Dlugubris_g %>% otu_table() %>% as.data.frame() %>% rowSums() %>% sort(decreasing = TRUE) %>% head(10)
```

To test if their diets are different, I will use a Permanova test. One of the assumptions of this test is that variance is similar between the groups being compared (i.e. Pangaeus and Dallasiellus). To test if data dispersion is the same between groups, I am using betadisper.

> From hereafter, I choose rarefaction at the 50% quartile depth, since it is the middle trade-off between number of samples and sequences per sample.

```{r prepare_data_rr50}
permanova_rr50 <- subset_samples(PBB_rr50, Sp.ID !="unknown") %>% prune_taxa(taxa_sums(.) > 1, .)
permanova_rr50 <- prune_samples(!is.na(sample_data(permanova_rr50)$Sp.ID), permanova_rr50)
```

```{r betadisper}
# Extract OTU table from phyloseq object, calculate Bray-Curtis distances, and calculate beta dispersion

otu_table <- t(as(otu_table(permanova_rr50), "matrix"))
bray_dist <- vegdist(otu_table, method = "bray")
metadata_rr50 <- data.frame(sample_data(permanova_rr50))

disper_SpID <- betadisper(bray_dist, metadata_rr50$Sp.ID)

# Test if dispersion between groups is significant
anova(disper_SpID)
```

Test is significant (p < 0.05). Permanova may be robust even when dispersion of data is unequal among groups being compared. However, I suspect that unequal sampling in months and sites may confound the test here (that is, for instance, if one species is more collected in one month/year and the other in a different month/year, diet may reflect plants available rather than differences in diet). Permanova is less robust for unequal sampling designs.

How unequal is sampling (month and sites)?

```{r sampling-design-rr50}
# Pbilineatus data (30 samples total)
# Month
filter(metadata_rr50, Sp.ID == "Pbilineatus") %>% group_by(Month) %>% summarize(month = length(Month)) # Mostly June, 19 samples
# Year
filter(metadata_rr50, Sp.ID == "Pbilineatus") %>% group_by(Year) %>% summarize(year = length(Year)) # Mostly 2020, 28 samples
# Sites
filter(metadata_rr50, Sp.ID == "Pbilineatus") %>% group_by(Site) %>% summarize(site = length(Site)) # Randolph: 12, Worth: 18

# Dlugubris data (31 samples total)
# Month
filter(metadata_rr50, Sp.ID == "Dlugubris") %>% group_by(Month) %>% summarize(months = length(Month)) # Mostly September, 24 samples
# Year
filter(metadata_rr50, Sp.ID == "Dlugubris") %>% group_by(Year) %>% summarize(year = length(Month)) # Mostly 2021, 28 samples
# Sites
filter(metadata_rr50, Sp.ID == "Dlugubris") %>% group_by(Site) %>% summarize(site = length(Site)) # Mostly Worth, 30 samples
```

The counts above indicate that although sampling per species is similar (30 and 31 samples for _Pangaeus_ and _Dallasiellus_, respectively), sampling was heavily biased towards non-overlapping months between species and, to a lesser extent, less overlap in sampling regions. Because plant phenology and flora composition may change significantly between Summer (e.g. June) and Fall (e.g. September), it may be difficult to distinguish diet differences between species due to month of sampling or species identity, or both.

I will test this data first assuming no differences due to month of sampling, but I will have Species nested in site, since it is less likely that sampling locations will be identical in their landscape and, thus, plant diversity.

But first, I need to address the issue of overdispersed data. I will use weighted UniFrac distances, that uses a phylogenetic approach to weigh the relative abundance of similar clades in community composition when comparing the dissimilarity between samples.

1. I start by making a phylogenetic tree of _trnF_ sequences, required for calculating UniFrac distances (this step takes long to be completed)
```{r tree-for-UniFrac-distances}
library(phangorn)
library(DECIPHER)
asv_ids <- colnames(otu_table)
refseq_phyloseq <- refseq(p_data.clean_rarefy)
refseq_phyloseq_rr50 <- refseq_phyloseq[names(refseq_phyloseq) %in% asv_ids]
permanova_rr50up <- merge_phyloseq(permanova_rr50, refseq_phyloseq_rr50)
alignment <- AlignSeqs(refseq_phyloseq_rr50, anchor=NA)
phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
dm <- dist.ml(phangAlign)
treeNJ <- NJ(dm)
mod.test <- modelTest(phangAlign) #this gives TVM+G(4)+I as the best model
fit = pml(treeNJ, data=phangAlign)
fitTVM <- update(fit, k=4, inv=0.2)
fitTVM <- optim.pml(fitTVM, model="TVM", optInv=TRUE, optGamma=TRUE,
        rearrangement = "stochastic", control = pml.control(trace = 0)) #this may take 15-20 min
rooted_fitTVM_tree <- midpoint(fitTVM$tree)
detach("package:phangorn", unload=TRUE)
permanova_rr50up_phytree <- merge_phyloseq(permanova_rr50up, rooted_fitTVM_tree)
```

2. Next, I calculate if data is still overdispersed using betadisper
```{r betadisper-UniFrac}
unifrac_dist <- UniFrac(permanova_rr50up_phytree, weighted = TRUE)
disper50_unifrac <- betadisper(unifrac_dist, metadata_rr50$Sp.ID)
anova(disper50_unifrac) #this result meets permanova assumptions (p>0.05)
```

Data is no longer overdispersed with UniFrac distances. We meet the Permanova assumption of similar dispersion!

3. Permanova

3.1. First define permanova terms
```{r permanova-terms}
Site_50 <- sample_data(permanova_rr50)$Site
Month_50 <- sample_data(permanova_rr50)$Month
Species_50 <- sample_data(permanova_rr50)$Sp.ID
metadata <- data.frame(sample_data(permanova_rr50))
```

3.2. Testing the relative importance of Month as a co-variable. Note that Species is nested in Site, to account for site-specific variation in landscape
```{r permanovaNoStrata}
adonis2(formula = unifrac_dist ~ Species_50/Site_50 + Month_50, data = metadata, permutations = 999) # Species p = 0.004, Month p = 0.423, Species:Site p = 0.272
```

3.3. Month is not significant! I will test the data one more time, but using Month as strata (or block).
```{r permanovMonthAsStrata}
adonis2(formula = unifrac_dist ~ Species_50/Site_50, data = metadata, permutations = 999, strata = Month_50) # Species p = 0.118, Species:Site p =0.299
```

The results are clear, we are not able to tell if diet is different between these two species because month of sampling is a confounding variable.

## Ordination
```{r ordination-preparedata}
# Prepare datasets
process_dataset <- function(dataset) {
  dataset_sub <- subset_samples(dataset, Sp.ID != "unknown") %>%
    prune_taxa(taxa_sums(.) > 1, .)
  dataset_sub <- prune_samples(!is.na(sample_data(dataset_sub)$Sp.ID), dataset_sub)
  datatest <- data.frame(sample_data(dataset_sub)) %>%
    mutate(Month_bias = case_when(
      Month == "June" ~ "June",
      Month == "September" ~ "September",
      TRUE ~ "Other"
    ))
    asv_ids <- rownames(otu_table(dataset_sub))
refseq_dataset_sub <- refseq_phyloseq[names(refseq_phyloseq) %in% asv_ids]
merge_phyloseq(dataset_sub, sample_data(datatest), refseq(refseq_dataset_sub))
}

# Apply to all datasets
PBB_rr25_f <- process_dataset(PBB_rr25)
PBB_rr50_f <- process_dataset(PBB_rr50)
PBB_rr75_f <- process_dataset(PBB_rr75)
```

```{r ordination-make-stre}
#Load required packages
library(microViz)
library(phangorn)


build_tree <- function(dataset_sub) {
  alignment <- AlignSeqs(refseq(dataset_sub), anchor=NA)
  phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
  dm <- dist.ml(phangAlign)
  treeNJ <- NJ(dm)
  fit <- pml(treeNJ, data=phangAlign)
  fitTVM <- update(fit, k=4, inv=0.2)
  fitTVM <- optim.pml(fitTVM, model="TVM", optInv=TRUE, optGamma=TRUE,
              rearrangement="stochastic", control=pml.control(trace=0))
  rooted_tree <- midpoint(fitTVM$tree)
  merge_phyloseq(dataset_sub, rooted_tree)
}

PBB_rr25up <- build_tree(PBB_rr25_f)
PBB_rr50up <- build_tree(PBB_rr50_f)
PBB_rr75up <- build_tree(PBB_rr75_f)
```

```{r saveTrees}
saveRDS(PBB_rr25up, "RDS/PBB_rr25up.rds")
saveRDS(PBB_rr50up, "RDS/PBB_rr50up.rds")
saveRDS(PBB_rr75up, "RDS/PBB_rr75up.rds")
```

```{r ordinationpcoaplot}
library(GUniFrac)
library(cowplot)
library(ggrepel)
library(microbiome)

PBB_rr25up1 <- readRDS("RDS/PBB_rr25up.rds")
PBB_rr50up1 <- readRDS("RDS/PBB_rr50up.rds")
PBB_rr75up1 <- readRDS("RDS/PBB_rr75up.rds")

datasets <- list(PBB_rr25up1 = PBB_rr25up1,
                 PBB_rr50up1 = PBB_rr50up1,
                 PBB_rr75up1 = PBB_rr75up1)

# Enhanced function with genus vectors
generate_pcoa_plot <- function(ps_object, add_genus_vectors = TRUE, p_max = 0.05, vector_scale = 0.2) {
  # Preprocess the phyloseq object
  ps_object <- tax_fix(ps_object)
  ps_object <- phyloseq_validate(ps_object, remove_undetected = TRUE)
  
  # Calculate weighted UniFrac distance
  unifracs = GUniFrac::GUniFrac(t(otu_table(ps_object)), phy_tree(ps_object), alpha = c(0, 0.5, 1))$unifracs
  wunifrac_dist <- as.dist(unifracs[, , "d_1"])
  
  # Perform PCoA
  pcoa <- cmdscale(as.matrix(wunifrac_dist), eig = TRUE, k = 2)
  scores <- as.data.frame(pcoa$points)
  colnames(scores) <- c("MDS1", "MDS2")
  
  # Add metadata
  metadata <- data.frame(sample_data(ps_object))
  plot_data <- cbind(scores, metadata)
  
  # Create variance variable for the plot axis labels
  var_explained <- round(100 * pcoa$eig / sum(pcoa$eig), 2)
  
  # Generate base PCoA plot
  pcoa_plot <- ggplot(plot_data, aes(x = MDS1, y = MDS2, color = Sp.ID, shape = Month_bias)) +
    geom_point(size = 5) +
    scale_color_brewer(palette = "Paired") +
    labs(
      x = paste0("MDS1 (", var_explained[1], "%)"),
      y = paste0("MDS2 (", var_explained[2], "%)"),
      color = "Species",
      shape = "Sampling Month"
    ) +
    theme_bw() +
    ggside::geom_xsideboxplot(aes(fill = Sp.ID, y = Sp.ID, group = Sp.ID), orientation = "y", show.legend = FALSE) +
    ggside::geom_ysideboxplot(aes(fill = Sp.ID, x = Sp.ID, group = Sp.ID), orientation = "x", show.legend = FALSE) +
    ggside::scale_xsidey_discrete(labels = NULL) +
    ggside::scale_ysidex_discrete(labels = NULL) +
    ggside::theme_ggside_void() +
    scale_fill_brewer(palette = "Paired")
  
  # Add species vectors if requested
  if (add_genus_vectors) {
    # Extract OTU table and convert to relative abundances
    genus_phyloseq <- aggregate_taxa(ps_object, level = "Genus")
    otu_data <- as.data.frame(t(otu_table(genus_phyloseq)))
    
    otu_rel <- otu_data / rowSums(otu_data)  # Convert to relative abundances
    
    # Fit species vectors using envfit
    genus_fit <- envfit(scores, otu_rel, permutations = 999)
    
    # Extract significant species vectors
    genus_scores <- as.data.frame(genus_fit$vectors$arrows)
    genus_pvals <- genus_fit$vectors$pvals
    significant_genus <- genus_scores[genus_pvals <= p_max, ]
    
    if (nrow(significant_genus) > 0) {
      # Scale vectors for better visualization
      significant_genus <- significant_genus * vector_scale
      
      significant_genus$labels <- rownames(significant_genus)
      significant_genus$MDS1_end <- significant_genus$MDS1
      significant_genus$MDS2_end <- significant_genus$MDS2
      
      # Add vectors to plot
      pcoa_plot <- pcoa_plot +
        geom_segment(data = significant_genus, 
                     aes(x = 0, y = 0, xend = MDS1_end, yend = MDS2_end),
                     arrow = arrow(length = unit(0.3, "cm")), 
                     color = "black", size = 0.8, alpha = 0.7,
                     inherit.aes = FALSE) +
        geom_text_repel(data = significant_genus,
                        aes(x = MDS1_end * 1.1, y = MDS2_end * 1.1, label = labels),
                        color = "black", size = 3, fontface = "italic",
                        inherit.aes = FALSE,
                        max.overlaps = 20,
                        box.padding = 0.5,
                        point.padding = 0.3,
                        segment.color = "grey50",
                        segment.size = 0.2)
    }
  }
  
  return(pcoa_plot)
}

# Create plots with species vectors - with error handling
pcoaplots <- list()
for (i in seq_along(datasets)) {
  cat("Processing dataset:", names(datasets)[i], "\n")
  tryCatch({
    plot <- generate_pcoa_plot(datasets[[i]], add_genus_vectors = TRUE, p_max = 0.05, vector_scale = 0.2)
    if (!is.null(plot)) {
      pcoaplots[[names(datasets)[i]]] <- plot
    } else {
      cat("Warning: Plot for", names(datasets)[i], "is NULL\n")
    }
  }, error = function(e) {
    cat("Error processing", names(datasets)[i], ":", e$message, "\n")
  })
}

# Check if we have any plots
if (length(pcoaplots) == 0) {
  stop("No plots were successfully generated")
}

  # Save the plots
# PBB data rarefied at 25% quantile  
ggsave("Figures/PCoA_25Q_with_vectors.pdf", plot = pcoaplots$PBB_rr25up1, height = 9, width = 12)
# PBB data rarefied at 50% quantile
ggsave("Figures/PCoA_50Q_with_vectors.pdf", plot = pcoaplots$PBB_rr50up1, height = 9, width = 12)
# PBB data rarefied at 75% quantile
ggsave("Figures/PCoA_75Q_with_vectors.pdf", plot = pcoaplots$PBB_rr75up1, height = 9, width = 12)
```

## Alpha Diversity
### Alpha Diversity is calculated within a sample rather than between samples; therefore we can skip normalizing data for this step; we don't need our control samples for this step, so we will exclude Colony samples

```{r alpha-diversity}
library(microbiome)
library(ggpubr)
library(knitr)
library(ggtext)
library(scales)
library(RColorBrewer)
pseq_alpha <- subset_samples(p_data.clean, Site!="Colony")
pseq_alpha <-aggregate_taxa(pseq_alpha, level = "Genus")
tab <-microbiome::diversity(pseq_alpha, index = "Shannon")

# Extract and prepare dataframe for plotting alpha diversity as a violin plot
# Note: when plotting, the OnDemand rendering of Rstudio does not show some markdown text formatting, such as italicized or bold words
pseq_alpha_meta <- microbiome::meta(pseq_alpha)
pseq_alpha_meta$Shannon <- tab$shannon
color_shape_scheme <- data.frame(Site = c("Randolph Pivot", "Randolph Shed", "Worth1_20", "Worth2_20", "Worth1_21", "Worth2_21"), ColorSite = c("#FB9A99","#E31A1C","#FDBF6F","#FF7F00","#CAB2D6","#6A3D9A"), ShapeSite = c("2", "3", "4", "8", "11", "14"))

pseq_alpha_meta <- left_join(pseq_alpha_meta, color_shape_scheme, by="Site")

pseq_alpha_plot <- ggviolin(pseq_alpha_meta %>% mutate(Site = factor(Site, levels = c("Randolph Pivot", "Randolph Shed", "Worth1_20", "Worth1_21", "Worth2_20", "Worth2_21"))), x="Site", y="Shannon", add="boxplot", fill="Site")+scale_fill_manual(values = c("Randolph Pivot" = "#FB9A99", "Randolph Shed" = "#E31A1C", "Worth1_20" = "#FDBF6F", "Worth2_20" = "#FF7F00", "Worth1_21" = "#CAB2D6", "Worth2_21" = "#6A3D9A"))

pseq_alpha_plot+ labs(
  x = "Sites",
  y = "Shannon index (diet for both *P.bilineatus* <br> and *D.lugubris* combined)"
) +
  theme(
    axis.title.x = element_markdown(),
    axis.title.y = element_markdown()
  )
ggsave("./Figures/General_violin_plot_Dec2024.pdf", width=15, height=10)
```


# Now let's group data by host species and plot the same type of plot again

```{r AlphaBySpecies}
pseq_alpha_meta %>% filter(Sp.ID=="Pbilineatus") %>% mutate(Site = factor(Site, 
   levels = c("Randolph Pivot", "Randolph Shed", "Worth1_20", "Worth1_21", "Worth2_20", "Worth2_21"))) %>% ggviolin(., x="Site", y="Shannon", add="boxplot", fill="Site") + labs(
  x = "Sites",
  y = "Shannon index (diet diversity)",
  title= "*Pangaeus bilineatus*"
) + facet_grid(~Month, scales = "free", space = "free") +
  theme(legend.position = "none",
  axis.title.x = element_markdown(),
  axis.title.y = element_markdown(),
  plot.title.position = "plot",
  plot.title = element_markdown(size = 11, lineheight = 1.2)) +scale_fill_manual(values = c("Randolph Pivot" = "#FB9A99", "Randolph Shed" = "#E31A1C", "Worth1_20" = "#FDBF6F", "Worth2_20" = "#FF7F00", "Worth1_21" = "#CAB2D6", "Worth2_21" = "#6A3D9A")) + font("x.text", size = 10, face = "bold") + coord_cartesian(ylim = c(0, 3)) + scale_y_continuous(expand = c(0, 0))

ggsave("./Figures/Pbilineatus_alpha_diversity_per_month_Dec2024.pdf", width=25, height=10)

pseq_alpha_meta %>% filter(SequenceBatch != "1") %>% filter(Sp.ID=="Dlugubris") %>% 
  mutate(Site = factor(Site, levels = c("Randolph Pivot", "Randolph Shed", "Worth1_20", "Worth1_21", "Worth2_20", "Worth2_21"))) %>%
  ggviolin(., x="Site", y="Shannon", add="boxplot", fill="Site") +
  labs(x = "Sites", y = "Shannon index (diet diversity)",title= "*Dallasiellus lugubris*") + facet_grid(~Month, scales = "free", space = "free")+
  theme(legend.position = "none",
        axis.title.x = element_markdown(),
        axis.title.y = element_markdown(),
        plot.title.position = "plot",
        plot.title = element_markdown(size = 11, lineheight = 1.2))+scale_fill_manual(values = c("Randolph Pivot" = "#FB9A99", "Randolph Shed" = "#E31A1C", "Worth1_20" = "#FDBF6F", "Worth2_20" = "#FF7F00", "Worth1_21" = "#CAB2D6", "Worth2_21" = "#6A3D9A")) + font("x.text", size = 10, face = "bold") + coord_cartesian(ylim = c(0, 3)) + scale_y_continuous(expand = c(0, 0))

ggsave("./Figures/Dlugubris_alpha_diversity_per_month_Dec2024.pdf", width=25, height=10)
```

Diversity barplot (samples split by species and blocked by month)

```{r barplot-diversity-genus}

library(cowplot)
library(grid)

process_phyloseq <- function(barplot.data) {
  # Step 1: Simplify the dataset
  barplot.clean <- barplot.data %>% 
    psmelt() %>% 
    filter(!is.na(Site)) %>% 
    filter(Site != "Colony") %>%
    filter(Kingdom == "Viridiplantae")

  # Step 2: Replace NA in "Species" column
  filtered_no_NA <- barplot.clean %>% 
    mutate(Genus = ifelse(is.na(Genus) & !is.na(Family), paste0(Family, " spp."),
                    ifelse(is.na(Genus) & !is.na(Order), paste0(Order, " spp."),
                    ifelse(is.na(Genus) & !is.na(Class), paste0(Class, " spp."),
                    ifelse(is.na(Genus) & !is.na(Phylum), paste0(Phylum, " spp."),
                    ifelse(is.na(Genus) & !is.na(Kingdom), paste0(Kingdom, " spp."), Genus))))))

  # Step 3: Initialize result containers
  month_plots <- list()
  all_genus <- list()

  # Step 4: Create color palette
  combined_genus <- unique(filtered_no_NA$Genus)
  color_palette <- RColorBrewer::brewer.pal(n= min(8, length(combined_genus)), name = "Dark2")
  if(length(combined_genus) > 8) {
    color_palette <- colorRampPalette(color_palette)(length(combined_genus))
  }
  combined_genus[length(combined_genus)+1] <- "Other"
  color_palette[length(color_palette)+1] <- "lightgray"
  names(color_palette) <- combined_genus
  peanut <- unlist(color_palette)
  peanut[names(peanut) == "Arachis"] <- "black"
  color_palette <- relist(peanut, color_palette)

  # Step 5: Define species to process
  species_list <- c("Pbilineatus", "Dlugubris")

  for (species in species_list) {
    species_data <- filtered_no_NA %>% filter(Sp.ID == species)

    # Step 5.1: Select relevant columns and sum Abundance by unique combinations
    species_simple <- species_data %>% 
      select(Sample, Abundance, Site, Month, Genus) %>% 
      group_by(Sample, Site, Month, Genus) %>% 
      summarize(Abundance = sum(Abundance), .groups = "drop")

    # Step 5.2: Process data for each "Month"
    for (month in unique(species_simple$Month)) {
      month_data <- species_simple %>% filter(Month == month)
      month_data <- month_data %>% group_by(Sample) %>%
      mutate(Abundance = ifelse(!Abundance == "0", Abundance/sum(Abundance), Abundance)) %>%
      ungroup()
      
    # Step 5.3: Find the 20 most abundant "Genus" and rename others as "Other"
      sort.Genus <- month_data %>% 
        count(Genus, wt = Abundance) %>%
        arrange(n) %>%
        mutate(relativeAb = n/sum(n)) %>%
        mutate(cumRelAb = cumsum(relativeAb)) %>%
        filter(cumRelAb >= 0.3) %>%
        pull(Genus)
      
      sort.Genus[length(sort.Genus)+1] <- "Arachis" # Add peanuts (Arachis) back, to make sure it is not placed in the "Other" category in the next step
      sort.Genus <- unique(sort.Genus)

      month_data <- month_data %>% 
        mutate(Genus = ifelse(Genus %in% sort.Genus, Genus, "Other")) %>% group_by(Sample, Site, Month, Genus) %>% 
      summarize(Abundance = sum(Abundance), .groups = "drop")


    # Step 5.4: Sum Abundance and sort Genus
      sort.Genus <- month_data %>% 
        count(Genus, wt = Abundance) %>% 
        arrange(desc(n)) %>% 
        pull(Genus)

    # Step 5.5: Get Sample order
      Sample.order <- month_data %>% 
        filter(Genus == sort.Genus[1]) %>% 
        arrange(desc(Abundance)) %>% 
        pull(Sample)

    # Step 5.6: Factor Sample/Genus and save month-specific object
      month_data <- month_data %>% 
        mutate(Sample = factor(Sample, levels = Sample.order)) %>% 
        mutate(Genus = factor(Genus, levels = rev(sort.Genus)))

      all_genus[[paste(species, month, sep = "_")]] <- unique(month_data$Genus)

    # Step 6: Create ggplot stacked barplot
      month_plot <- month_data %>% 
        ggplot(aes(x = Sample, y = Abundance, fill = Genus)) + 
        geom_bar(stat = "identity", width = 1) + 
        theme_classic() + 
        theme(axis.text.x = element_blank(),
              axis.title.x = element_blank(),
              axis.text.y = element_blank(),
              axis.title.y = element_blank(),
              axis.ticks.x = element_blank(),
              axis.ticks.y = element_blank(),
              axis.line = element_blank(),
              legend.position = "none") + 
        labs(title = month) + 
        theme(plot.title = element_text(hjust = 0.5)) +
        scale_fill_manual(values=color_palette)

      month_plots[[paste(species, month, sep = "_")]] <- month_plot
    }
  }


  # Step 7: Combine ggplots with cowplot (this isn't perfect, but can be improved in Inkscape)
  species_plots <- list()

  for (species in species_list) {
    months <- sort(unique(filtered_no_NA %>% filter(Sp.ID == species) %>% pull(Month)))
    month_plot_list <- lapply(months, function(month) month_plots[[paste(species, month, sep = "_")]])
    species_title <- ifelse(species == "Pbilineatus", "Pangaeus bilineatus", "Dallasiellus lugubris")
    
  
    species_plots[[species]] <- cowplot::plot_grid(
      plotlist = month_plot_list, 
      ncol = length(months) 
    )
  }

  final_plot <- cowplot::plot_grid(species_plots[["Pbilineatus"]], species_plots[["Dlugubris"]], nrow = 2, rel_heights = c(1.2, 1))
  final_plot
  #ggsave("./Figures/top70percentAbundanceGenus.pdf", width = 15, height = 10)

  
  # Extra step: make a legend plot that unifies taxa from all months/species data. This plot can be manually added using Inkscape
  legend_plot <- ggplot(data.frame(Genus = names(color_palette)[names(color_palette) %in% unlist(all_genus)], Value = 1), aes(x = Genus, y = Value, fill = Genus)) + geom_col() +
  scale_fill_manual(values = color_palette) +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(fill = guide_legend(nrow = 2))

  legend <- get_legend(legend_plot)
  grid.newpage()
  #pdf("./Figures/legend_top70percentAbundanceGenus.pdf", width=20, height=20)
  grid.draw(legend)
  dev.off()

  return(list(final_plot = final_plot, species_plots = species_plots, color_palette = color_palette))
}
q <- process_phyloseq(p_data.clean)

```



```{r heatmapForAugust}

heatmap_data <- p_data.clean %>%
  subset_samples(!is.na(Site)) %>%
  subset_samples(Site != "Colony") %>%
  subset_taxa(Kingdom == "Viridiplantae") %>%
  microbiome::aggregate_taxa(., "Genus") %>%
  microbiome::transform(., "compositional") %>%
  psmelt()  %>% filter(Sp.ID == "Pbilineatus" | Sp.ID == "Dlugubris") %>%
    filter(Month == "August")

#filter instances where Genus has zero abundance across all samples
heatmap_data <- heatmap_data %>% group_by(Genus) %>% filter(any(Abundance > 0)) %>% ungroup
heatmap_data$Sp.ID <- factor(heatmap_data$Sp.ID, levels = c("Pbilineatus", "Dlugubris"),
                             labels = c("Pangaeus bilineatus", "Dallasiellus lugubris"))
heatmap_data$Genus <- factor(heatmap_data$Genus, levels = c("Wahlenbergia", "Unknown", "Ulmus",
                                                            "Triticum", "Symphiotrichum", "Stellaria",
                                                          "Solanum", "Sambucus", "Rubus", "Raphanus",
                                                          "Pinus", "Paspalum", "Lamium", "Gossypium",
                                                          "Digitaria", "Brassica", "Arachis", "Ambrosia",
                                                          "Allium"),
                             labels = c("<i>Wahlenbergia</i>", "Unknown", "<i>Ulmus</i>",
                                                            "<i>Triticum</i>", "<i>Symphiotrichum</i>", "<i>Stellaria</i>",
                                                          "<i>Solanum</i>", "<i>Sambucus</i>", "<i>Rubus</i>", "<i>Raphanus</i>",
                                                          "<i>Pinus</i>", "<i>Paspalum</i>", "<i>Lamium</i>", "<i>Gossypium</i>",
                                                          "<i>Digitaria</i>", "<i>Brassica</i>", "<i>Arachis</i>", "<i>Ambrosia",
                                                          "<i>Allium</i>"),)
#create heatmap
heatmap_august <- ggplot(heatmap_data, aes(x= Sample, y = Genus)) + geom_tile(aes(fill=Abundance)) +
  scale_fill_gradient(low = "white", high = "darkblue") +
    geom_text(
    aes(label = round(Abundance,2)),
    size = 1.25,
        color = ifelse(
      abs(heatmap_data$Abundance) > 0.6, 
      'white', 
      'black'
    )
  ) +
  theme_minimal() + 
  facet_grid(~Sp.ID, scales = "free") +
  theme(
    text = element_text(size = 14),
    axis.ticks.x=element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x=element_blank(),
    axis.text.y=element_markdown(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    strip.text.x = element_text(face = "italic"),
    panel.border = element_rect(colour = "black", fill=NA, linewidth=1))

# Save image in PDF
 pdf("./Figures/heatmap_whitebackground.pdf",height=6,width=6)
 heatmap_august
 dev.off()
```

So, is diet different among PBBs for August samples?

```{r August-samples-different?}
august_data <- p_data.clean %>%
  subset_samples(!is.na(Site)) %>%
  subset_samples(Site != "Colony") %>%
  subset_taxa(Kingdom == "Viridiplantae") %>%
  subset_samples(Sp.ID == "Dlugubris" | Sp.ID == "Pbilineatus") %>%
  subset_samples(Month == "August") %>%
    prune_taxa(taxa_sums(.) > 0, .) %>%
    prune_samples(sample_sums(.) > 0, .) %>%
  microbiome::aggregate_taxa(., "Genus") %>%
  microbiome::transform(., "compositional")
august_otu <- t(as(otu_table(august_data), "matrix"))
august_dist <- vegdist(august_otu, method = "bray")
metadata_august <- data.frame(sample_data(august_data))
august_disper <- betadisper(august_dist, metadata_august$Sp.ID)
anova(august_disper)
Species_pbb <- metadata_august$Sp.ID
permanova <- adonis2(august_dist ~ Species_pbb,
                    permutations=999)
print(as.data.frame(permanova))
```

No significant difference found! What if we test differences related only to taxonomical composition (given less weight to relative abundance).

```{r August-samples-different-taxonomy}
# august_data <- p_data.clean %>%
#   subset_samples(!is.na(Site)) %>%
#   subset_samples(Site != "Colony") %>%
#   subset_taxa(Kingdom == "Viridiplantae") %>%
#   subset_samples(Sp.ID == "Dlugubris" | Sp.ID == "Pbilineatus") %>%
#   subset_samples(Month == "August") %>%
#     prune_taxa(taxa_sums(.) > 0, .) %>%
#     prune_samples(sample_sums(.) > 0, .) %>%
#   microbiome::aggregate_taxa(., "Genus") %>%
#   microbiome::transform(., "compositional")
# august_otu <- t(as(otu_table(august_data), "matrix"))
august_dist <- vegdist(august_otu, method = "jaccard")
metadata_august <- data.frame(sample_data(august_data))
august_disper <- betadisper(august_dist, metadata_august$Sp.ID)
anova(august_disper)
Species_pbb <- metadata_august$Sp.ID
permanova <- adonis2(august_dist ~ Species_pbb,
                    permutations=999)
print(as.data.frame(permanova))
```
Still no differences!

```{r species-overlap-histogram}
histogram_data <- p_data.clean %>%
    psmelt() %>% 
    filter(!is.na(Site)) %>% 
    filter(Site != "Colony") %>%
    filter(Sp.ID != "unknown") %>%
    select(c("Indiv_ID", "Sp.ID", "Season", "collection_date")) %>% 
  summarise(.by = "Indiv_ID", across(c("Sp.ID", "Season", "collection_date"), max))
histogram_data$Year <- format(as.Date(histogram_data$collection_date), "%Y")
histogram_data$Month <- format(as.Date(histogram_data$collection_date), "%m")

# We will redefine the Season variable here, because there are some mistakes currently, and we also would like to use the meteorological definition of seasons, which is based on temperature changes, instead of the astronomical definition.

histogram_data <- histogram_data %>% mutate(season = case_when(
          Month %in% c("06", "07", "08") ~ "Summer",
          Month %in% c("09", "10", "11") ~ "Fall",
          Month %in% c("03", "04", "05") ~ "Spring", TRUE ~ NA_character_
))

occurrence_pbb <- ggplot(histogram_data %>% mutate(Season = factor(Season, levels = c("Spring", "Summer", "Fall"))), aes(x = Season, fill = Sp.ID)) +
  geom_bar(position = position_dodge2(width=0.9, preserve="single")) +
  scale_fill_manual(labels = c("<i>D. lugubris</i>", "<i>P. bilineatus</i>"),
                    values = c("Pbilineatus" = "darkblue", "Dlugubris" = "lightblue")) +
  facet_grid(~ Year, scales = "free_x", space="free_x") +
  labs(x = "Season", y = "Count", fill = "Species") +
  theme(
    text = element_text(size = 14),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_markdown(),
    panel.background = element_blank(),
    axis.ticks.x=element_blank()
  )

pdf("./Figures/PBB_occurence_by_season.pdf",height=4,width=6)
occurrence_pbb
dev.off()
```

```{r banana}
musa <- p_data.clean_mlt %>% filter(Genus == "Musa") %>% filter(Abundance > 0) 
musa$Site <- factor(musa$Site, levels = c("Colony", "Randolph Pivot", "Worth1_20"), 
                                  labels = c("Colony", "RandolphP_20", "Worth1_20"))
musa %>% ggplot(., aes(x = Site, y = Abundance, fill = Indiv_ID)) + geom_bar(stat = "identity") + theme_classic()
ggsave("./Figures/banana.pdf")
```

```{r sesamum}
sesamum<- p_data.clean_mlt %>% filter(Genus == "Sesamum") %>% filter(Abundance > 0) 
sesamum$Site <- factor(sesamum$Site, levels = c("Randolph Shed", "Worth1_20", "Worth2_20", "Worth1_21", "Worth2_21"), 
                                  labels = c("RandolphS_20", "Worth1_20", "Worth2_20", "Worth1_21", "Worth2_21"))
sesamum %>% ggplot(., aes(x = Site, y = Abundance, fill = Indiv_ID)) + geom_bar(stat = "identity") + theme_classic()
ggsave("./Figures/sesamum.pdf")
```

```{r savetable}
p_data.clean_mlt <- psmelt(p_data.clean)

write.csv(p_data.clean_mlt, "./all_processed_PBB_data.csv")
```

# General statistics for the manuscript

How many samples identified using RAD-seq data?

```{r samples identified stats}
# use metadata file where bowtie data had been added
metadata_stat <- read.table("./metadata_assembly/Burrower_bugs_metadata_DEC32024.csv", row.names = 3, sep = ",", header = TRUE)
metadata_stat$SequenceBatch <- as.factor(metadata$SequenceBatch)
metadata_stat$collection_date <- as.Date(metadata$collection_date, format = "%m/%d/%y")
metadata_stat$Month <- factor(metadata$Month, levels = month.name)

# Total number of samples (excluding controls for primer contamination and samples where barcode information was lost)
print("Total number of samples")
metadata_stat %>% filter(!is.na(Site)) %>% nrow()

print("Total number of samples with RAD-seq data available")
metadata_stat %>% filter(mol.ID == "yes") %>% nrow()

# Pbilineatus
print("Pbilineatus samples")
metadata_stat %>% filter(mol.ID == "yes") %>% filter(Sp.ID == "Pbilineatus") %>% nrow()

# Dlugubris
print("Dlugubris samples")
metadata_stat %>% filter(mol.ID == "yes") %>% filter(Sp.ID == "Dlugubris") %>% nrow()

# Unknown
print("Unknown samples")
metadata_stat %>% filter(mol.ID == "yes") %>% filter(Sp.ID == "unknown") %>% nrow()
```

How many reads processed? How many samples at the start and at the end?
```{r sample raw reads count}
# Raw read count can be obtained by counting sequences in all sequence files, regardless of whether they are sample or control
prim4 <- as.data.frame(rbind(prim1, prim2, prim3))
print("All raw reads")
sum(prim4$reads.in)
print("Raw Reads(RR): Only samples, excluding primer controls, and samples with barcodes missing")
exclude_samples <- c("control_F1.fastq", "control_F12.fastq", "control_F16.fastq", "control_F34.fastq", "control_F60.fastq", "control_F61.fastq", "control_F64.fastq", "control_F69.fastq", "control_F74.fastq", "control_F79.fastq", "MikeCrossley-UGA-022421-bc1097--bc1105-Q40.fastq", "MikeCrossley-UGA-022421-bc1099--bc1105-Q40.fastq", "MikeCrossley-UGA-022421-bc1105--bc1111-Q40.fastq", "MikeCrossley-UGA-022421-bc1111--bc1112-Q40.fastq", "MikeCrossley-UGA-022421-bc1111--bc1169-Q40.fastq", "unassigned.fastq", "bc1099--bc1108-Q40.fastq")
sum(prim4[!(row.names(prim4) %in% exclude_samples),]$reads.in)
print("RR: Only field samples")
colony_samples <- c("bc1099--bc1103-Q40.fastq", "bc1098--bc1106-Q40.fastq", "bc1099--bc1104-Q40.fastq", "bc1099--bc1105-Q40.fastq", "bc1099--bc1169-Q40.fastq", "bc1097--bc1103-Q40.fastq", "bc1097--bc1104-Q40.fastq", "bc1097--bc1105-Q40.fastq", "bc1097--bc1106-Q40.fastq")
exclude_samples2 <- c(exclude_samples, colony_samples)
sum(prim4[!(row.names(prim4) %in% exclude_samples2),]$reads.in)
print("Number of field samples")
length(prim4[!(row.names(prim4) %in% exclude_samples2),]$reads.in)
print("RR: Only colony samples")
sum(prim4[(row.names(prim4) %in% colony_samples),]$reads.in)
```
```{r sample processed reads count}
# number of field samples kept after quality control, and number of sequences
print("Number of sequences kept for field samples")
p_data.clean %>% subset_samples(!is.na(Site)) %>% subset_samples(!Site == "Colony") %>% sample_sums() %>% as.data.frame() %>% sum(is.numeric(.))
print("Number of samples (field) kept")
p_data.clean %>% subset_samples(!is.na(Site)) %>% subset_samples(!Site == "Colony") %>% sample_sums() %>% as.data.frame() %>% nrow()
# number of colony samples kept after quality control, and number of sequences
print("Number of sequences kept for colony")
p_data.clean %>% subset_samples(!is.na(Site)) %>% subset_samples(Site == "Colony") %>% sample_sums() %>% as.data.frame() %>% sum(is.numeric(.))
print("Number of samples (colony) kept")
p_data.clean %>% subset_samples(!is.na(Site)) %>% subset_samples(Site == "Colony") %>% sample_sums() %>% as.data.frame() %>% nrow()
```



```{r sample processed burrower bug species count}
sp_updated_p_data.clean <- p_data.clean 
sample_data(sp_updated_p_data.clean) <- metadata_stat
# Pbilineatus samples
print("Number of Pangaeus bilineatus samples")
sp_updated_p_data.clean %>% subset_samples(!is.na(Site)) %>% subset_samples(!Site == "Colony") %>% subset_samples(Sp.ID == "Pbilineatus") %>% sample_sums() %>% as.data.frame() %>% nrow()
# Dlugubris samples
print("Number of Dallasiellus lugubris samples")
sp_updated_p_data.clean %>% subset_samples(!is.na(Site)) %>% subset_samples(!Site == "Colony") %>% subset_samples(Sp.ID == "Dlugubris") %>% sample_sums() %>% as.data.frame() %>% nrow()
```

```{r save-summary-table}
write.csv(sp_updated_p_data.clean %>% subset_samples(!is.na(Site)) %>% psmelt(), "./all_data_processed.csv", row.names = FALSE)
```

```{r diet-table}
dietP <- sp_updated_p_data.clean %>% microbiome::aggregate_taxa(., "Genus") %>% subset_samples(!Site == "Colony") %>% subset_samples(Sp.ID == "Pbilineatus")
dietP <- as(otu_table(dietP), "matrix")
dietP <- as.data.frame(dietP)
dietP$Species <- row.names(dietP)
row.names(dietP) <- NULL
dietP <- dietP %>% rowwise() %>% mutate(Pangaeus_bilineatus = sum(c_across(where(is.numeric)), na.rm = TRUE), 
                                       Sample_presence_Pb = paste0(sum(c_across(1:62) > 0, na.rm = TRUE), " (",
                                                                   sum(!is.na(c_across(1:62))), ")")) %>% ungroup()
write.csv(dietP, "./Pb_diet_per_sample.csv", row.names = FALSE)

dietD <- sp_updated_p_data.clean %>% microbiome::aggregate_taxa(., "Genus") %>% subset_samples(Sp.ID == "Dlugubris")
dietD <- as(otu_table(dietD), "matrix")
dietD <- as.data.frame(dietD)
dietD$Species <- row.names(dietD)
row.names(dietD) <- NULL
dietD <- dietD %>% rowwise() %>% mutate(Dallasiellus_lugubris = sum(c_across(where(is.numeric)), na.rm = TRUE), 
                                       Sample_presence_Dl = paste0(sum(c_across(1:61) > 0, na.rm = TRUE), " (",
                                                                   sum(!is.na(c_across(1:61))), ")")) %>% ungroup()
write.csv(dietD, "./Dl_diet_per_sample.csv", row.names = FALSE)

diet_all <- full_join(dietP, dietD, by = "Species") %>% select(Species, Pangaeus_bilineatus, Sample_presence_Pb,
                                                                 Dallasiellus_lugubris, 
                                                                 Sample_presence_Dl) %>% mutate(sum_taxa = Pangaeus_bilineatus + 
                                                                                                  Dallasiellus_lugubris) %>% 
                                                                                                  filter(sum_taxa > 0)
write.csv(diet_all, "./diet_summary_both_Pb_and_Dl.csv", row.names = FALSE)
```


